---
title: "Basics of R and data visualization for linguists"
subtitle: "Summer School of Linguistics, Czechia, August 2022"
author: Andres Karjus   https://andreskarjus.github.io
output: 
  html_document: 
    toc: yes
    number_sections: no
    fig_width: 5 
    fig_height: 4
editor_options:
  chunk_output_type: console
---


# Introduction

Hi! Please work through this short intro *before* the workshop on, especially
the package installation part - work until the line which says 
*This is the end of the intro* - we'll continue from there on together. 
If you come prepared, you'll be able to follow the workshop easily; 
if you don't work through this short intro, your experience will not be very good.

This R Markdown worksheet contains both introductions and code blocks. 
As a quick overview, the intro containts:

1. Instructions on how to change some useful settings
2. A very short&simple exercise to get you familiar with basic R.
3. A code block that will install the required packages - please *don't forget to do that*.
If you don't install the packages, you won't be able to do any of the exercises in the workshop. You might have noticed a message above the script pane saying "Packages required but are not installed" - we'll get to that in a second. But first:


# Configure these RStudio options, to make your life about 200% easier

- *Soft Wrap*: on the menu bar top left, go to *Code* -> enable *Soft-wrap long lines* 
(this will make using the script editor much easier, 
by wrapping long lines so you won't have to keep scrolling left and 
right all the time).
- You can also enable *Rainbow parentheses* in the same menu if you'd like - it'll make nested parentheses easier to follow.
- *Table of contents*: if you have a big enough screen, a nice addition you can enable
is be the document outline, which gives you a handy overview of things: in the
top right corner of this script pane click the Outline button with 6 bars 
(second from the right). On the other hand, if your screen is small: try resizing 
the panes by dragging the borders inside RStudio.
You can also search the script using *CTRL+F* (CMD+F on Mac).
- Is your RStudio kind of slow or sluggish? Troubleshooting option: try disabling the spellchecker: *Tools* -> *Global Options*, choose the *Spelling* tab 
on the left, disable the real-time speller.



# A quick pre-workshop exercise for beginners

If all of this so far looks and feels new to you, then this here's something I'd recommend doing before the workshop to get a feel for R coding, so we can move on to the more interesting stuff quicker together. If you've used R before, feel free to skip this and go straight to the package installation part (definitely do the installation part!).
Also notice how this line here is quite long and without manual line breaks - if you didn't change the Soft Wrap setting above - you'd have to scroll left and right and left and right to be able to read it. If you successfully changed that one setting above, then the text should be nicely wrapped within the script pane, no left-right scrolling required.

So far you've seen only free-running text. The shaded block below is a code block. RStudio colors it differently than the rest of the document:

```{r}
# This is a comment, and below it is a line of code:
print( "Hello! Put your text cursor on this line (click on the line). Anywhere on the line. Now press CTRL+ENTER (PC) or CMD+ENTER (Mac). Just do it." )

# The command above, when executed (what you just did), printed the text in the *console pane* below. Also, this here is a comment - comments start with a # hashtag.
# Commented parts of the script (anything after a # ) are not executed. Feel free to add your own comments anywhere inside the code blocks.
# This R Markdown file has both code blocks (gray background in the default theme) and regular text (white background).
# Code blocks start and end with the 3 ``` symbols; make sure you don't delete them.
# Always write code inside code blocks.

```

Everything outside the code blocks is just regular text. Feel free to also add your own notes anywhere, including right here (no #comment symbol required).
Now let's try some more simple functions.

```{r, eval=F}

sum(1,10) # cursor on the line, press CTRL+ENTER (or CMD+ENTER on Mac)
# You should see the output (sum of 1 and 10) in the console. 
# Important: you can always get help for a function and check its input parameters by executing 
help(sum)  # put the name of any function in the brackets
# ...or by searching for the function by name in the Help tab on the right.

# Exercise. You can also write commands directly in the console, and executing them with ENTER. Try some more simple maths - math in R can also be written using regular math symbols (which are really also functions). Write 2*3+1 in the console below manually, and press ENTER. You can also go back to previous commands by pressing the up arrow on your keyboard. 
# Don't skip this, do it.


# Now let's plot something. The command for basic plotting is, surprisingly, plot().
plot(x = 42, main = "The greatest plot in the world") # execute the command; a plot should appear on the right.
# So that was not very exciting. But notice that a function can have multiple inputs, or arguments. In this case, the first argument is the data for the x axis (here a vector of length one), and the second is 'main', which specifies the main title of the plot. 
# You can make to plot pop out in a bigger window by pressing the 'Zoom' button above the plot panel on the right.

# Let's plot some 100 random numbers, generated with the rnorm() function.
hist(x=rnorm(100))               # a histogram
plot(x=rnorm(100), y=rnorm(100)) # a scatterplot

# Note that in R, spaces and line breaks don't matter in terms of syntax, so this gives the same result:
plot(x= rnorm(100) , 
     y = rnorm( 100)
     )    

# By the way, you can also always search in the script file using CTRL+F (CMD+F on a Mac).
# If you make a mistake in the script, you can always Undo it (CTRL+Z; or CMD+Z on a Mac).
```

These basic plots don't look exactly amazing. I know - that's why we'll be using packages like ggplot2 and plotly in the workshop that make it easy to produce beautiful colorful wonderful graphs, and we'll see how to make them interactive too.

```{r, assignment, eval=F}
# Let's try another thing. We'll use the paste() command, which concatenates (glues) strings (words and such) into a single string.
paste("hello", "world") # two inputs, outputs single string

# Most functions follow this pattern: there's input(s) and maybe some parameters, separated by commas, something is done to the input, and then there's an output. Here the "input" is the two strings "hello" and "world".
# If an output is not assigned to some object, it usually just gets printed in the console. It would be easier to work with data, if we saved it in an object. For this, we need to learn assignement, which in R works using the equals = symbol.
sentence = paste("Hello", "world!")  
# what it means: "sentence" is the arbitrary name of a (new) object, the equals sign = signifies assignement, with the object on the left and the data on the right 
# (note that there's two ways of doing assignement, to define objects in R: either with = or <- , we'll be using the = here). 

# In this case, the "data" is the output of the paste() function. Instead of printing in the console, the output is assigned to the object.
sentence # run this line to inspect: calling an object usually prints its contents into the console below. Try it.

# Let's try assignement one more time; let's create an object with your name. 
myname = " "    # put your name between the quotes, like this: myname = "Andres"
# Now run this line: note that the output will depend on what you assigned to myname:
paste("Hello", myname, "you're doing great!")  
# This works because paste() concatenates the strings with the value of the object myname.

```

That's the end of the beginners exercise block. Now make sure to do the installation part below, and then you're all done!



# *Install the packages now*

Let's get to installing. Think of packages like boxes of ready-made code that somebody else has written, that you won't have to write and can just use. If you get an error while installing, see the troubleshooter below. RStudio now also notifies of missing packages on top of the script pane.

Run the block below - this will take some time, so while it's doing its thing, go back to the course webpage and read through the section 4, the Code Troubleshooting bit (also please don't forget to put your name in the confirmation form there, once package installation finishes). 
In some cases R will ask for your further input to continue with installation (if so, see the steps below). It will most likely ask you if you'd like to *install packages from source* - if so, click No (or type no if the prompt appears in the Console).

```{r install.packages, eval=F}
# Run this code block; it should start throwing messages about installing a bunch of stuff in the console. This will take some time but only needs to be done once!
p=c("tidyverse","gapminder","plotly","quanteda","quanteda.textplots","quanteda.textstats","umap","shadowtext","text2vec","igraph","visNetwork","rworldmap","maps","rmarkdown","markdown");install.packages(p);x=p%in%rownames(installed.packages());if(all(x)){print("All packages installed successfully!")}else{print(paste("Failed to install:", paste(p[!x]), ", try again and make sure you have internet connection."))}
# If it asks "Do you want to install from sources the package which needs compilation?" just go for "no".
```

Troubleshooting: if you get an error or confusing prompt when running the above, see here; otherwise don't mind this part:

- "Cannot download...": make sure you're connected to the internet.
- Prompt with `Do you want to install from sources the package which needs compilation? (Yes/no/cancel)` - type *no* in the Console and press enter (or if it's a box, click the *No button*). Unless you're on a Linux machine (or if binary installation fails), in which case go for yes of course.
- Prompt with `Would you like to create a personal library...` - click Yes.
- Prompt with `One or more packages are loaded, restart yes/no/cancel?` - try Yes, but if it occurs again, restart R and click No.
- Warning `package ... is not available (for R version ...)` - seems you didn't update R; please do that first (by installing the newest R, see the installation instructions again).
- Some error about `RcppArmadillo`: ignore it.
- Warning `Rtools is required to build R packages but is not currently installed.`: ignore it.
- If all else fails, try restarting RStudio and running the command above again. If it still reports installation failures, get in touch with me, preferably by email (report your operating system, the steps you took, and the errors you encountered, and send screenshots if possible). We won't have time to mess with installation during the workshop itself.


 ---
 ---
 --- 

All good and packages installed? Then this is the end of the intro. 

Thanks for installing everything and preparing your RStudio so that we can go straight to the interesting stuff in the workshop and start learning useful things together. Please go back to the installation prep website now, and sign your name into the confirmation form at the end of the page.

 ---
 ---
 ---
 

(P.S. If you're tempted to scroll onward and check out the materials beforehand, feel free, but also don't be alarmed by the fairly large number of exercises under each section - this is so that if some people already know some R, they can do those extra ones instead of being bored out of their minds. It's totally ok if you take it slow and only do the first couple exercises under each section during the workshop. But also whenever you feel like you're falling behind, raise a hand.)
 --- 






# -------


# Welcome to the workshop!

This is where we start together in the live workshop. If you have a little message on top of this window saying packages are missing, please click it or go back to the package installation section to install ASAP.


# **Load the packages**

Let's start by loading the required packages. I'll put this right here in the beginning so you won't miss it. Throughout this worksheet, you'll see a number of functions and also a few datasets from these packages.
If you run the code and *won't get any errors in the console*, and a plot saying *Welcome!* appears on the right, in the Plots pane, then packages loading probably worked. Yay!

```{r packages, message=F, warning=F, echo=T, eval=T}
# Load the necessary packages - this needs to be done every time you restart R
# To run the entire code block here, click the little green triangle > in the top right corner of the code block. Do that now.
# Or put your cursor on the first line of the code and press CTRL+ENTER (CMD+ENTER)

suppressWarnings(suppressMessages({  # -> Run this! (it might take a moment)
  library(tidyverse)          # includes ggplot2, dplyr, tibble
  library(gapminder)          # provides a dataset we'll need
  library(plotly)             # interactive plots
  library(quanteda)           # a corpus pkg & its addons
  library(quanteda.textplots)
  library(quanteda.textstats)
  library(umap)       
  library(shadowtext) 
  library(text2vec) 
  library(igraph)   
  library(visNetwork) 
  library(rworldmap)  
  library(maps)  
  ggplot(gapminder)+annotate("text",x=0,y=0,label="Welcome!") # a little test
}))
```

- If you got an error that a *package is not found* and/or the plot did not appear, then you've got something missing; go to the install.packages block above (in the pre-workshop intro) and install. If it's a different error or if the plot did not appear, ask for help.

- (For those wondering why it's called "library" - think of it as a function that reaches into your library of packages and pulls the ones you want; see the Packages tab on the right if you want to see your whole library)

- By the way, if you haven't tried enabling the document outline/table of contents yet, you can try doing that now: click on the "Outline" icon with the 6 little bars, in the top right of this script pane. The sidebar that appears can be resized just like the other panes. If you have a tiny screen it might take up too much space, but otherwise it's pretty useful.

 ---
 

# Basic data operations and plots

Let's get down to business.
```{r basics, eval=F}
# We will be using the gapminder dataset from the `gapminder` package that we loaded above
library(gapminder) # this call is just here to remind you that we're using this package

# We can inspect the data using convenient R commands.
class(gapminder)    # type of the object: it's a "tibble", a kind of dataframe (I know, this probably doesn't help much right now. It's a table of sorts:)
dim(gapminder)      # dimensions of that table
summary(gapminder)  # produces an automatic summary of the columns
head(gapminder)     # prints the first rows

# In RStudio, you can also have a look at dataframe type objects by clicking on the little "table" icon next to it in the Environment section (top right), or by running this command:
View(gapminder) # this will open a new tab next to your script tab.

# help(gapminder)     # built in datasets often also have help files attached; this one is quite helpful - go have a look what the variables actually stand for, before moving on.


# Accessing values in the dataset
gapminder[1:6, ]  # a slice of first 6 rows; the syntax: [rows, columns] 
gapminder[1:6 , c("country", "pop", "year")]  # select 3 columns and first 6 rows
# This is how base R works; we can use the Tidyverse package dplyr to do this in a more transparent way:
gapminder %>%     # the pipe operator
  slice(1:6) %>%  # slice of rows 1 to 6
  select(country, pop, year)  # select these columns

# Basic plotting:
hist(gapminder$lifeExp, breaks=10)
boxplot(gapminder$lifeExp, ylab="Life expectancy")
plot(pop ~ lifeExp, data=gapminder)

```

While the base plots work just fine in R, you might have noticed the syntax is not the most straightforward, nor are the default looks particularly appealing. We will therefore look into using a better plotting package below instead.


 ---


# ggplot2

We'll now switch to an alternative plotting package, `ggplot2`. It uses a different approach to plotting, and a slightly different syntax. It also comes with default colors and aesthetics which many people find nicer than those of the base `plot()`. 
A particularly useful feature of ggplot2 is its extendability (or rather the fact people are eager to extend it), with an ever-growing list of addon-packages on CRAN with an extended selection of themes and more niche visualization methods. It's also easy to make ggplots interactive using the `plotly` package (examples later).

Let's build our first ggplot up layer by layer:
```{r}
library(gapminder)
library(ggplot2) 
library(dplyr)
# we actually already loaded these; ggplot2 and dplyr are part of tidyverse
# but I included package loading calls in code blocs where a new package is introduced - so you can keep track which new functions come from which package.


# You can think of ggplot as putting layers of different elements on a canvas:
ggplot()  # 1. The "empty canvas"; calling this just plots an empty plot
ggplot(data=gapminder)  # 2. let's add the data argument (but it's still an empty plot, as we have not asked for any variables to be shown)

ggplot(data=gapminder, mapping=aes(x=lifeExp, y=pop)) # 3. Define the x and y axes using aes() 
# (which stands for "aesthetic mappings") - this makes something show up.

# 4. Now let's add a "geom" - these are layers that plot thnings like points or lines.
# Layers are "added" using the + operator
# But also they only work if you use the +, just putting the lines of code under one another won't be enough.
ggplot(gapminder, aes(x=lifeExp, y=pop))+  # notice the plus
  geom_point()   

# If provided in the correct order, parameter names can be omitted; so I won't be spelling out the data= part here anymore.

# 4.1. I also want you to get into the habit of putting a NULL in the end of ggplot code blocks: it doesn't do anything (being null), but this extra bit will save you from a certain fairly confusing error which happens if you would accidentally leave a trailing + in the end of a ggplot call. Make sure the NULL is always in the very very end, and never put a "+" after the NULL.
ggplot(gapminder, aes(x=lifeExp, y=pop))+
  geom_point()+
  NULL

# Sanity check: what are we actually looking at? What are the variabels and their relationship?


# 5. We can add parameters to the geoms, like color, fill, size, alpha/transparency:
ggplot(gapminder, aes(x=lifeExp, y=pop))+
  geom_point(color="purple", size=2, alpha=0.2)+  
  NULL
# "purple" is a string (a color name), so use quotes


# 6. Let's color the points conditionally by continent instead: 
# for that, define the coloring variable in the aes() function:
ggplot(gapminder, aes(x=lifeExp, y=pop, color=continent))+
  geom_point()+ 
  NULL
# Defining variables for color, fill, size and shape automatically generate a legend.

# So explicit color like "blue" or "purple" or size=1.2 goes into the geom_point() options; but if you want to color a geom by the values of a variable, do that in the aes(). So aes(color="blue") won't work, but aes(color=continent) works. Only variable names go in the aes(). 
# We'll also see below how to change the colors of a conditional coloring palette.


# 7. The order of things in a ggplot block matters:
ggplot(gapminder, aes(x=lifeExp, y=pop, color=continent))+
  geom_point(color="red", size=2, shape=15)+ 
  geom_point(color="blue", size=0.5)+ 
  NULL
# The little blue circles are plotted on top of the bigger red squares, because the blue circles line of code is after the red points line.

# 8. Let's also try adding a different "theme", a more minimal one; it will replace the default.
ggplot(gapminder, aes(x=lifeExp, y=pop, color=continent))+
  geom_point()+
  theme_minimal()+                # add before before theme()
  theme(legend.position = "top")+ # add after theme_* if one is present
  NULL
# Again, order matters: if using the theme-modifying function theme(), it needs to go after the line that defines the overall theme.

```

All ggplot2 functions are just like other R funtions, they have a name (such as `geom_point`), parameters ( `color="blue", size=2`), the parameters are separated with commas, and surrounded by brackets: `geom_point(color="blue", size=2)`. The only difference is that the functions are joined into a block using the `+` operator. Pressing the tab key while inside the function brackets pops up the available parameter list.

Recap: you can think of the different ggplot elements - geoms, themes, scales etc as layers, added on top of one another.



## Exercise

This is the same dataset as above, but we're using a subset of the data, just Europe for now (subsetted using the `filter()` function from the dplyr package). You'll notice that some the exercises have multiple possible solutions - feel free to experiment!

Do the following exercises one by one: do the requested addition or change, and then run the code to see how it looks. If you get an error, it's probably something in the new piece of code you just added or changed. Make sure to only write code inside code blocks, not out here.

Important: when you're done with the last exercise (or the last exercise you finished when the instructor told the class to start uploading solutions), take a screenshot of your plot or use the ` Export > Copy to clipboard ` option above the plot pane, then paste your result here on this common clipboard: 
https://hackmd.io/@andreskarjus/SkTrzBZgK/edit

If you get an error you can't solve, raise a hand and ask for help.


The exercises:

1. We already tried coloring by continent. Now explore the data by coloring by country or year, and try to interpret the plot that comes out (discuss with your neighbour if you're sitting together with somebody). Remember, explicit colors such as "blue" are defined in the geom, while conditional coloring (such as "color by country") are defined in the aes() or aesthetic mapping function.

Also, tip: if at any point it seems like the code you're running is "not doing anything", just check if the last line of the Console starts with a > or a +. If it's a +, then put the cursor in the Console and press Esc.
    
```{r}

ggplot(data = gapminder %>% filter(continent=="Europe"), 
       mapping = aes(
         x=year, # life expectancy on the x axis
         y=lifeExp,     # population on the y axis
         # here: define which variable should be mapped to color:
         
         #
         )) + 
  # add geoms, scales and themes between here...
  geom_point(  )+   # modify the points by adding parameters between the ( )

  # ...and here
  NULL  # while keeping this in the end

```

Extra exercise if you're fast:
  - If coloring by year, try using ` scale_colour_viridis_c() ` instead (scales are added with a + just like geoms).
  - There's a lot of points there - either make them a bit smaller by adding ` size=0.7 ` into geom_point(), or make them transparent (` alpha=0.7 `), or change the point shape to an empty circle (` shape=1 `), or all of these options.
  - It's easy to change axis labels too: add the `labs(x="", y="", title="")` layer and specify the titles in the quotes.
  - Try removing or moving the legend using ` + theme() `, specifying the ` legend.position ` parameter with value "none", "bottom", etc (with quotes). Make sure the theme() layer comes after theme_bw(), theme_minimal() etc, as theme() modifies the options of those.
  
Even more extra exercises if you're super duper fast:
- Try replacing points with text: instead of points, use 
` geom_text(aes(label=country), size=2, hjust=1) ` here (the hjust argument makes the labels right-aligned, which looks nicer than the default center-alignment).
    - Probably doesn't make sense to color by country any more, so color by year instead.
    - Extra: you can also try removing the points by deleting or commenting out the geom_point() line, or making the points either smaller or less transparent.
    - Extra: try changing the default theme for another one like ` theme_bw() ` (themes are added with a + like other layers)
- Try labeling with geom text, but so that only the last year (2007) is labelled, by defining the data argument separately in the geom_text() call, and setting its value to a subset like this: 
` data=gapminder %>% filter(continent=="Europe", year==2007) `
- Or use shorter labels: a quick way to do it is to use the substring function, which you can use right inside the aes() in geom_text() like this: 
` aes(label=substr(country,1,3)) ` - you can now either remove the points or just make them smaller (e.g. size=0.2).
- Try more themes and color scales. 

Finally, copy-paste your plot to https://hackmd.io/@andreskarjus/SkTrzBZgK/edit




## Solution (don't look here yet;)

```{r}
# These are some possible solutions to the exercises above

# 1.
ggplot(data = gapminder %>% filter(continent=="Europe"), 
       mapping = aes(
         x=lifeExp, # life expectancy on the x axis
         y=pop,     # population on the y axis
         color=year
         )) + 
  geom_point(size=0.7, alpha=0.7)+  
  scale_colour_viridis_c()+
  labs(x="Life expectancy", 
       y="Population size", 
       title="Europe 1952-2007")+
  theme_bw()+
  NULL

# 2.
ggplot(data = gapminder %>% filter(continent=="Europe"), 
       mapping = aes(
         x=lifeExp, # life expectancy on the x axis
         y=pop,     # population on the y axis
         color=country
         )) + 
  geom_point(size=0.2)+  
  geom_text(aes(label=substr(country,1,3)), size=3, hjust=1)+
  
  labs(x="Life expectancy", 
       y="Population size", 
       title="Europe 1952-2007")+
  theme_bw()+
  theme(legend.position = "none")
  NULL

```


## Exercise 2

Let's try doing a quick timeseries plot as well

    
```{r}
# it's basically all the same, just this time we use a different geom for lines. Let's also try a new continent.


ggplot(data = gapminder %>% filter(continent=="Oceania"), 
       mapping = aes(
         x=year,
         y=lifeExp,
         color=country
         )) + 
  # add geoms, scales and themes between here...
  geom_line()+   # New!

  theme(legend.position = "none")+
  # ...and here
  NULL  # while keeping this in the end

```

So this plot gives life expectancy over the years; I've hidden the legend because there's way too many countries, the legend would be huge. Let's add country labels directly on the plot instead:
- ` geom_text(aes(label=country), data=gapminder %>% filter(continent=="Oceania", year==2007), hjust=0, size=2)+ `  - that adds labels, but because we filter the data here once more, it labels only the last year.
- The labels are hard to see though! Let's give them some space; add this:
  ` scale_x_continuous(expand = expansion(mult = c(0, 0.2)))+ `
- Extra: you can also add points on top of the lines - try adding the geom_point() back in.
- And the axis labels could be nicer, fix them using ` labs() `


When done, paste your plot to   https://hackmd.io/@andreskarjus/SkTrzBZgK/edit

 ---

## Quick sneak peek: interactive plots

```{r}
library(plotly)

# save the plot as an object (that's what the assignement operator "=" does)
g = ggplot(data = gapminder %>% filter(continent=="Oceania"), 
       mapping = aes(x=year, y=lifeExp, color=country)) + 
  geom_line()+
  geom_point()+
  geom_text(aes(label=country), 
            data=gapminder %>% filter(continent=="Oceania", year==2007), 
            hjust=0, size=2)+
  scale_x_continuous(expand = expansion(mult = c(0, 0.2)))+ 
  theme(legend.position = "none")+
  # ...and here
  NULL  # while keeping this in the end
g # take a look

ggplotly(g) # run this; hover your cursor over the plot that appears.

```


 ---








# Some basic corpus metadata exploration

For this section, we'll just use a little corpus that comes with the quanteda package, the inaugural speeches of US presidents.
```{r timeseries, eval=T, echo=T}
library(quanteda)  # a corpus linguistics package; we'll also make use of a dataset in it:
library(plotly)    # for ggplotly

# Let's inspect the data first
data_corpus_inaugural # it's a quanteda corpus object; when called, also displays some metadata
head(tokens(data_corpus_inaugural[[1]])) # the first words of the first speech
head(summary(data_corpus_inaugural))     # quanteda has a summary function for its corpus objects
sum(summary(data_corpus_inaugural)$Tokens) # total number of words

# Let's record that output as an object for later use:
metadata = summary(data_corpus_inaugural)

# Let's plot the lengths of the speeches over time:
ggplot(metadata, aes(x=Year, y=Tokens)) + 
  geom_point()+
  theme_minimal() +
  NULL



```

## Exercises 3

- This plot might be easier to follow though if the points were connected; add a ` geom_line() ` layer
- But it would be helpful to see the names of the presidents as well; you could add a custom secondary axis, or annotations: ` geom_text(aes(label=President), nudge_y = 100, angle=90, hjust=0 ) `
- Or, we could make it an interactive plot... save the ggplot as an object (something like `x = ggplot(metadata, aes...` will do), and call ` ggplotly(x) ` on that object (this is from the plotly package, which we already loaded in the beginning).

Finally, paste your plot to  https://hackmd.io/@andreskarjus/SkTrzBZgK/edit

## Extra exercises

- Instead of length over the years, we could also explore type to token relationships - put the Types variable on the x-axis instead (and maybe color by Year)
- Make a ggplot that shows the distribution of speech length (in tokens) for different parties; possibly useful geoms could be geom_boxplot, geom_violin, or geom_beeswarm from the ggbeeswarm package (already loaded) - in the latter case, feel free to also color by Year.
- Or could also use geom_density or geom_histogram, and split into facets by Party, facet_wrap(~Party).




# Exploring corpora

## Words

```{r}
library(quanteda)
library(quanteda.textplots)

titles_dfm = data_corpus_inaugural %>% 
  tokens(remove_punct = T, remove_symbols = T, remove_numbers = T) %>% 
  tokens_tolower() %>% 
  tokens_remove(stopwords()) %>% 
  dfm()

titles_dfm # have a look - it's a document-term matrix
topfeatures(titles_dfm) # pull most frequent words
  
textplot_wordcloud(titles_dfm, 
                   min_size = 2, max_size = 10, 
                   color=terrain.colors(10) ) %>% suppressWarnings()
# adjust the size variables if it looks too small or big on your screen

# This is definitely not a very scientific visualization, but can serve as a nice illustration once in a while.
```


Using the content of the speeches, we could also map them out in some n-dimensional space. Let's give that a try.

```{r}
library(umap)       # dimension reduction package we'll be using here
library(shadowtext) # ggplot addon for shaded labels

# Let's parse the corpus and distill it into a doc-term matrix
parsed = 
  data_corpus_inaugural %>% 
  tokens(remove_numbers = T, remove_punct = T) %>%  # tokenize
  dfm(tolower = T) %>%                              # into dfm (also lowercase)
  dfm_remove(c(stopwords('english'),          # remove stopwords
               "can", "may", "every", "*ly"), # also remove -ly adverbs
             valuetype="glob") %>%  
  dfm_wordstem() %>%  # also stem: remove suffixes to get a more compact/comparable lexicon
  dfm_tfidf() 
# this also applies TF-IDF (term frequency - inverse document frequency) weighting to our matrix; this lowers the importance of common words but increases the importance of words which distinguish documents.
parsed[1:3, 1:7]  # matrix with weights instead of frequencies, and words are stemmed
ncol(parsed) # lexicon size

# Quick comparison, how big would the lexicon be if we didn't do any cleaning, lowercasing and stemming
data_corpus_inaugural %>% tokens() %>% dfm() %>% ncol()


# get 2D coordinates from the UMAP dimension reduction algorithm and add the metadata
coords =  umap(as.matrix(parsed))$layout %>% 
  as.data.frame() %>% 
  mutate(year = summary(data_corpus_inaugural)$Year,
         speech=summary(data_corpus_inaugural)$Text
         )

# Plot:
ggplot(coords, aes(V1, V2, label=speech, color=year))+
  geom_point()+
  geom_text(hjust=-0.1, size=3)+
  scale_color_viridis_c()+
  theme_dark()+
  theme(axis.title=element_blank(),
        legend.position = "none")+
  NULL

# We could also plot all the words according to their usage frequencies over time; let's rerun the pipeline once more
parsed_words = 
    data_corpus_inaugural %>% 
  tokens(remove_numbers = T, remove_punct = T) %>% 
  dfm(tolower = T) %>%            
  dfm_wordstem() %>%
  dfm_remove(c(stopwords('english'), 
               "can", "may", "every", "*ly"), valuetype="glob") %>% 
  dfm_trim(min_termfreq = 10) %>%     # exclude very low frequency words
  dfm_smooth() %>%                    # smoothing, for later log-transform
  dfm_weight("prop") %>%              # normalize by document (which have different lengths)
  dfm_weight(scheme="logcount", force=T) %>%   # transform frequencies to log scale
  t() %>% as.matrix()       # transpose (since we're interested in words this time)

# why the log scaling? because words in a text are not distributed uniformly, but rather according to what's referred to as the Zipf's law - there are always a few very frequent words and a long tail of very infrequent words.

# Let's run another UMAP model (this may take a bit longer)
coords2 =  umap(parsed_words)$layout %>% as.data.frame()

# add the words and years (and some extra info we'll use later;)
metadata = summary(data_corpus_inaugural)
coord_metadata = coords2 %>% 
  mutate(word=rownames(.)) %>% 
  mutate(maxvalue = apply(parsed_words, 1, max)) %>% 
  mutate(maxyear = metadata$Year[apply(
    parsed_words, 1, function(x) which.max(x))]
    ) %>% 
  mutate(topspeeches = apply(
    parsed_words, 1, function(x) metadata$Text[head(order(x, decreasing = T),3)] %>% 
      paste(collapse=", ")  )
    ) %>% 
  mutate(topspeeches = paste(word, "\n", topspeeches))
# the last two calls fetch the year where a given word is the most frequent

# Let's plot: it places words that are frequent in similar years closer
# we'll use geom_shadowtext from the shadowtext package for shaded labels
# Dark blue = most common in earlier times, lighter = most frequent year in recent times
# Light word among dark words: something that was likely used back in the day, and now again
# Dark gray: words with no particularly outstanding year (set to NA above).
ggplot(coord_metadata, aes(V1, V2, color=maxyear, label=word))+
  geom_shadowtext(size=3, bg.color="white")+
  scale_color_viridis_c(option="E", end = 0.9, na.value = "gray10")+
  labs(color="most\nfrequent\nin year...")+
  NULL

# That is a looooot of words though, and quite hard to read. One solution would be to only plot a sample of the words:
# this groups the data by decades and samples top words from each group,
# and also sets the size to be the maximum log frequency value of the word, so more important words are highlighted.
# While we're at it, why not try a different color scheme too.
ggplot(data=coord_metadata %>% group_by(round(maxyear/10)) %>% sample_n(3), 
       aes(V1, V2, color=maxyear, label=word, size=maxvalue))+
  geom_point(data=coord_metadata, alpha=0.3)+
  geom_shadowtext(hjust=-0.1, bg.color="black")+
  scale_color_viridis_c(option="E", end = 0.9, na.value = "gray15")+
  scale_size(guide="none")+
  labs(color="most\nfrequent\nin year...")+
  theme_void()+
  theme(plot.background = element_rect("black"),
        panel.background = element_rect("black"),
        legend.text = element_text(color="gray")
        )+
  NULL

# Wouldn't it be nice if the plot showed just some labels, but then you could hover with your mouse to see more labels...?
```


## Making it interactive

```{r plotly_conversions}
library(plotly)    # for doing interactive plots
# plotly can be used to create the same sorts of plots as you've done with the ggplot() function, except interactive. 
# It can be used to create interactive plots from scratch, or to convert (most) ggplots. 

# Let's re-do the same plot as above, but save it as an object
g = ggplot(data=coord_metadata %>% group_by(round(maxyear/10)) %>% sample_n(3), 
       aes(V1, V2, color=maxyear, label=word, size=maxvalue, text=topspeeches))+
  geom_point(data=coord_metadata, alpha=0.3)+
  geom_text(hjust=-0.1)+
  scale_color_viridis_c(option="E", end = 0.9, na.value = "gray15")+
  scale_size(guide="none")+
  labs(color="most\nfrequent\nin year...")+
  theme_void()+
  theme(plot.background = element_rect("black"),
        panel.background = element_rect("black"),
        legend.text = element_text(color="gray")
        )+
  NULL
# note the extra parameter text=topspeeches - this records the top 3 speeches where this word is most frequent, and can be passed on to plotly.

ggplotly(g, tooltip="text") # this is the ggplot -> plotly converter function
# explore a bit; some light points among dark clouds and vice versa are quite interesting.
# troubleshooting: on some older computers with certain graphics hardware, this might not display: in that case click the little "show in new window" icon (arrow and box) top right of the plotting area to open in a browser.
```




# Heatmaps and text similarity

Another way to compare all variables to all variables all at once is to use a heatmap. Unlike dimension reduction such as UMAP, no information is reduced or compressed, but the interpretation is perhaps not immediately as intuitive as reading a scatterplot of a dimension reduction.

```{r}
library(quanteda)
library(quanteda.textstats)
# turn the corpus into a doc-term matrix again
docterm = data_corpus_inaugural %>% 
  tokens(remove_punct = T, remove_symbols = T, remove_numbers = T) %>% 
  dfm(tolower = T) %>% 
  dfm_remove(stopwords()) %>% 
  dfm_wordstem() %>% 
  dfm_tfidf()
  
# Let's have a quick look at the tfidf scores matrix:
docterm[1:5, 1:5]

# Let's calculate the cosine similarity of the texts (speeches), as similarity between the vectors across words
docsim = textstat_simil(docterm, method="cosine"); diag(docsim)=NA

# This yields a pretty large matrix (n*n documents), which would be pretty hard to comprehend just by staring at it...
dim(docsim)
docsim[1:5, 1:5] # first five
# Let's turn it into a heatmap visualization instead. One extra step though: this is a "wide" format matrix, while ggplot expects data in a "long" format, so let's convert first.
docsim_long = as.data.frame.table(as.matrix(docsim), responseName = "similarity") # run this first

ggplot(docsim_long, aes(Var1, Var2, fill=similarity)) + 
  # add things between here...
  geom_tile() +
  
  theme_bw() + 
  
  # ...and here.
  NULL

```

## Exercises 4

- The default color palette is not contrastive enough here, swap it with ` scale_fill_viridis_c(na.value="white", option="D") ` (feel free to try other viridis options "A"-"E")
- You can't really see the x axis values; set a better angle by adding: ` theme(axis.text.x = element_text(angle=90,hjust=1,vjust=0.5)) ` - and always make sure the modifying theme() comes after theme preset commands like theme_bw()
- Inspect the visualization and discuss it if you're doing this sitting together with somebody. Given that the speeches are in a diachronic order, what is the interpretation that the similarity is higher (lighter colors) near the diagonal, and darker in the opposing top left and bottom right corner? Or find the president whose second term inaugural speech was the most similar to his first term speech in terms of words used.

Finally, paste your plot to  https://hackmd.io/@andreskarjus/SkTrzBZgK/edit




# Exploring topics

While we're at it, let's try to probe into the corpus of speeches and use some more interactive plotting tools to visualize it.
```{r plotly, eval=T, echo=T}
library(tidyr)    # part of tidyverse; used here to gather data into long format
library(quanteda) # more of that
library(text2vec) # that's new; will use for topic models

# These lines of codes will create a document-term matrix that we can use to extract the top terms (after removing stopwords) from the speeches, but also to train a topic model and visualise its contents.
docterm2 = docterm = data_corpus_inaugural %>% 
  tokens(remove_punct = T, remove_symbols = T, remove_numbers = T) %>% 
  dfm(tolower = T) %>% 
  dfm_remove(stopwords()) %>% 
  dfm_wordstem() # no tfidf this time, as LDA works with counts

# Quick look into what's in there:
docterm2
docterm2[1:3, 1:5] # each document as a vector of words

# Let's train a quick topic model with 5 topics:
lda = LDA$new(n_topics = 5); topicmodel=lda$fit_transform(docterm)

# the object is just a big matrix d*t
topicmodel[1:2, ] # columns are topics, documents are probability distributions
sum(topicmodel[1, ]) 

# extract keywords from each topic, paste together into vectors
# note that the results might be a little different for you and a neighbour, as LDA is not fully deterministic (longer training would make results converge more)
topterms = lda$get_top_words(n = 10, lambda = 0.3) %>% 
  apply(2,paste,collapse=" ")
topterms # that's a bit more human-readable

# cast the document-topic distribution as long data:
tidymodel = as.data.frame(topicmodel) %>% 
  rownames_to_column("speech") %>% 
  gather("topic","value", V1:V5) %>% 
  mutate(topic=factor(topic, labels = topterms))

# top keywords for each topic are plotted in the legend:
ggplot(tidymodel, aes(x=speech, y=value, fill=topic)) + 
  geom_bar(position="stack", stat="identity") +
  guides(fill=guide_legend(nrow=5,title.position="top")) +
  coord_cartesian(expand = 0) +
  theme(axis.text = element_text(angle=45, hjust=1),
        legend.position = "top",
        legend.justification = "left"
        )+
 
  NULL

```

### Exercises 5

- Try another theme or color palette for scale_fill_discrete(), or specify your own 5 colors using e.g. ` scale_fill_manual(values=c("gold", "skyblue","blue","forestgreen","darkred" )) `
- Play around with the model itself and then plot again; try a different number of topics (n_topics in the LDA parameters) or a different lambda for term keyness, or add more keywords (the n = 10 parameter above). If you increase n_topics and the the fill_manual, make sure to also add more colors (or use an automatic scale), otherwise you get the "Insufficient values" error.
- Make this interactive using ggplotly() (save the ggplot as an object first, call ggplotly on it)
- you can now remove the legend (since hover labels do its job); set legend.position to "none" in theme().

Finally, paste your plot to  https://hackmd.io/@andreskarjus/SkTrzBZgK/edit




# Graphs and networks

## Social networks

The following example will look into plotting social networks of who knows who.
```{r igraph_networks, eval=T, echo=T}
library(igraph)   # graph operations and plotting

# Create an object with some random Scottish people (this could be a sample from a sociolinguistic study or whatever)
scots=c("Angus","Archibald","Baldwin","Boyd","Cinead","Craig","Diarmid","Donald","Duncan","Eachann","Erskine","Ethan","Fergus","Fingal","Fraser","Hamilton","Iain","Irvine","James","Muir","Mungo","Owen","Raibert", "Lyall", "Margaret", "Mairi", "Morag", "Murdina","Rhona", "Sorcha", "Thomasina","Una") 
nscots = length(scots) # record the number of people in an object
# call the nscots object to see how many there are

# Let's create some data, as friendship links between pairs of people; no need to think about this too hard for now though.
set.seed(1); mates = tibble(from=sample(scots,50,T,prob=(1:32)^2), to=sample(scots,50,T)); mates$x=apply(mates,1,function(x)paste(sort(x),collapse=""));mates=mates %>% .[!duplicated(.$x),] %>% .[.[,1]!=.[,2],] %>% .[,1:2]

mates # what it looks like:

scotgraph = graph_from_data_frame(mates, directed=F, vertices=scots) # convert data frame into a graph object (igraph has a variety of import functions like this)


scotgraph       # have a look at the scotgraph object (list of links/"edges"
plot(scotgraph) # the raw data in the graph object is not particularly useful; plotting the graph will help... 
# but while igraph comes with powerful machinery for manipulating and analyzing graphs, its plotting engine uses base R graphics and is not particularly attractive.

# Bonus: some graph statistics - igraph is good at stuff like that:
ecount(scotgraph) # how many links in the network
sort(degree(scotgraph), decreasing = T)[1:3] # top most popular people (vertex degree, i.e. how many edges/links a vertex/node has)
distances(scotgraph, v = "Fergus", to = "Donald") # how distant are these two lads in the network (least n edges)
mean_distance(scotgraph, unconnected = T) # average distance between the vertices (people)
# Looks like Duncan is a bit of a radge, nobody want tae be pals with him:(
```



## Interactive network graphs

```{r visnetwork}
library(visNetwork) 

# Create an object with some random Scottish people (this could be a sample from a sociolinguistic study or whatever)
scots=c("Angus","Archibald","Baldwin","Boyd","Cinead","Craig","Diarmid","Donald","Duncan","Eachann","Erskine","Ethan","Fergus","Fingal","Fraser","Hamilton","Iain","Irvine","James","Muir","Mungo","Owen","Raibert", "Lyall", "Margaret", "Mairi", "Morag", "Murdina","Rhona", "Sorcha", "Thomasina","Una") 

# Prepare the data in the required format for visNetwork
nodes = data.frame(id=scots, label=scots) # the nodes object
# Let's create some random links between them:
set.seed(1); edges = 
  data.frame(from=sample(scots,40,T), to=sample(scots,40,T)) %>% 
  filter(to!=from)
  

# Plot it - it will open in the Viewer pane instead of the Plots pane:
visNetwork(nodes = nodes, edges = edges)
# Try clicking on the nodes, moving them, and zooming. Pretty neat, no? You can also modify the physics engine to adjust the gravitational pull between the nodes, or disable it.

# Adjust some parameters; these can be added directly to the data, or with dedicated functions (we'll see that soon enough as well)
nodes$size = 15              # change size by just adding a column
nodes$color = c(rep("navy", 24), rep("tomato", 8))
visNetwork(nodes = nodes, edges = edges)

```


## Citation networks

In the following examples, we'll use the inaugural speeches of US presidents again. We'll start by looking into which presidents mention or address other presidents in their speeches. We'll extract the mentions programmatically rather than hand-coding them.
```{r}
library(quanteda) # speeches
library(dplyr) # already loaded with tidyverse; used here a bit

# Some pre-processing:
speeches = gsub("Washington DC", "DC", data_corpus_inaugural) # replacing city name to avoid confusion with the president Washington (hopefully)
metadata = summary(data_corpus_inaugural)
presidents = unique(metadata$President)


# The following piece of code looks for names of presidents in the speeches using grep(). Just run these lines of code:
mentions = tibble()
for(i in presidents){
    m = grep(i, speeches)
    mentions = rbind(mentions, 
                     tibble(from=metadata$President[m], 
                            to=rep(i, length(m)),
                            year = metadata$Year[m]
                     )  )
    }

# Have a look at the data
mentions

# Note: this is not perfect - the code above concatenates mentions of multiple speeches by the same re-elected president, "Bush" as well as "Roosevelt" refer to multiple people, and other presidents might share names with other people as well. You can check the context of keywords using quanteda's kwic() command:
kwic(data_corpus_inaugural %>% tokens(), "Monroe")


# Why not take a look at the big picture as well:
mentions %>% 
  count(to) %>% 
 ggplot(aes(x=n, y=to) ) + 
  geom_bar(stat="identity") + 
  scale_y_discrete(limits=presidents) +
  NULL


# Let's use visNetwork:
presnodes = data.frame(id=presidents, label=presidents) # nodes in required format
# check how it looks before we add all the fancy stuff:
visNetwork(nodes = presnodes, edges = mentions) 

# This is ok, but the layout is really not ideal - we can adjust things easily though:
visNetwork(nodes = presnodes, edges = mentions)  %>% 
  visNodes(size = 10, shadow=T, font=list(size = 30)) # add %>% here

  

```

## Exercises 6

Now use pipe %>% notation and the following functions to adjust the visNetwork plot. Feel free to play around with the parameters! Make sure you check how the graph changes after each addition, so you'll see what each bit adds:
- add ` visIgraphLayout("layout_in_circle", smooth=T) ` using the pipe (borrow a better layout from the igraph package)
- ` visEdges(arrows = "to",  shadow=T, smooth=list(type="discrete"), selectionWidth=5)  `
- ` visOptions(highlightNearest = list(enabled = T, hover = T, degree=1, labelOnly=F, algorithm="hierarchical"), nodesIdSelection = T) ` -  interactive selection options



## Exercise 6 alternative

If diving into yet another plotting paradigm and package (visNetwork) feels a bit much right now, then feel free to continue exploring ggplot instead:
```{r}

# Make this graph better by adding nicer labels, possibly color or themes
mentions %>% 
  count(to) %>% 
 ggplot(aes(x=n, y=to) ) + 
  geom_col() + 
  scale_y_discrete(limits=presidents) +
  NULL

# Or improve and explore this one (the year is the year of mentioning the given president), possibly replacing points with names and/or years.
ggplot(mentions, aes(x=year, y=to) ) + 
  geom_point() + 
  scale_y_discrete(limits=presidents) 

# Or, instead of a network, the same data could be expressed as a heatmap; improve this using notes from the heatmap exercise above:
ggplot(mentions, aes(x=to, y=from, fill=year) ) + 
  geom_tile() + 
  scale_y_discrete(limits=presidents)+
  scale_x_discrete(limits=presidents) 


```






 ---------------------

# Final words on attributions, citing and references.

A word on R and its packages. It's all free open-source software, meaning countless people have invested a lot of their own time into making this possible. If you use R, do cite it in your work (use the handy `citation()` command in R to get an up to date reference, both in plain text and BibTeX). To cite a package, use `citation("package name")`. You are also absolutely welcome to use any piece of code from this workshop, but I would likewise appreciate some acknowledgement of that:)

 ---

Do play around with these exercises later when you have time, and look into the bonus sections below for extras. If you get stuck, Google is your friend; also, check out www.stackoverflow.com - this site is a goldmine of programming (including R) questions and solutions.

Also, if you are looking for consulting on data analysis and visualization, or info on upcoming workshops, take a look at my website https://andreskarjus.github.io/ 
If you'd like to stay updated keep an eye on my Twitter @AndresKarjus (for science content) and @aRtofdataviz (for R, dataviz and workshops related stuff).




 ---
 
 ---
 
 ---










# --------

# Various things from previous workshops (if we have time left over)


## Animations

It's also easy to generate animations in R, either with gganimate (produces gifs out of ggplots) or with plotly. With the latter, the ggplotly command can also produce animations, provided you specify the variable for the "frame" (and "ids") parameter in ggplot, which will then be passed on to plotly (of course you can construct animations using the native plotly syntax as well, but that syntax is a bit different, so we won't go into that today).
```{r, eval=F}
g = ggplot(gapminder,   # first let's create and save a ggplot
           aes(gdpPercap, lifeExp, 
               label=country,
               color = continent,
               size = pop,
               frame = year, ids = country   # these 2 parameters make the animation work!
               )) +
  geom_point(alpha=0.5) +    # this stuff should be somewhat familiar by now
  geom_text(size=2, color="black", alpha=0.3)+
  scale_x_continuous(limits=c(0,50000))+  # I'll exclude some outliers
  theme_minimal()+
  NULL

ggplotly(g) %>% style(textposition = "right")

```

## Maps

Mapping is pretty easy too, we can just use ggplot. If doing more advanced mapping, have a look at the sf and leaflet packages. We're plotting a very basic map here, but you could easily import more detailed polygon data to plot e.g. regional, dialectal or historical maps.
```{r, eval=F}
library(rworldmap)  # provides generic world map
library(maps)       # provides a dataset
library(shadowtext) # nicer text labels for ggplot

# This pulls a simple map of Estonia, and some data on settlements from a global dataset.
newmap = joinCountryData2Map(countryExData, joinCode = "ISO3", nameJoinColumn = "ISO3V10", mapResolution = "low") %>% fortify(mymap) %>% subset(id=="Latvia")
places = world.cities %>% filter(country.etc == "Latvia") %>% arrange(desc(pop))

ggplot(places,   # places is defined as the main dataset, for point and label locations
       aes(long, lat, 
           size=pop,   # size and color by population
           color=pop, 
           label=name)
       ) + 
  geom_polygon(data=newmap,  # the map is used as data for the polygons
               aes(long, lat, group = group), inherit.aes = F,
               color="black", fill="gray98", alpha=0.7) +
  geom_point()+
  geom_shadowtext(data=places %>% filter(pop>20000), 
                  hjust=1.1, vjust=-0.2,size=3, bg.color="white")+
  scale_size(range=c(0.5,10))+  # scale for the points
  coord_fixed()+
  theme_minimal()+
  theme(legend.position = "none", axis.title = element_blank())+
  NULL

```

Or if you'd like to create interactive 3D maps and terrain models, look into the rayshader package. I've copied a little example here, but it won't work unless you got the rayshader and raster packages installed (if you want to give it a try, install and load them later yourself).
```{r, eval=F}
install.packages("rayshader") # this requires an extra package to be installed
library(rayshader)  # package for shaded terrain models

# 2D map:
map2d = montereybay  %>%
  sphere_shade(texture = "desert")  %>%
  add_shadow(ray_shade(montereybay, sunaltitude=20, zscale=50),
             max_darken=0.1)
plot_map(map2d)

# 3D map (this may take a moment to render!)
map3d = montereybay  %>%
  sphere_shade(texture = "desert") %>%
  add_shadow(ambient_shade(montereybay), 0) %>%
  add_shadow(ray_shade(montereybay, zscale = 1, sunaltitude = 89),max_darken=0.7)

plot_3d(map3d, montereybay, 
        water = TRUE, waterdepth = -90,
        watercolor="imhof2", waterlinecolor="white", waterlinealpha=0.3,
        zscale = 50,              # elevation exaggeration
        fov = 0, theta = 135, zoom = 0.5, phi = 45, 
        windowsize = c(x=30, y=10, w=1200, h=700), # adjust window size if needed
        triangulate=T, max_error = 0.1) # lower values = sharper plot (slower!), set triangulate=F to disable optimizer

```

We looked into the plotly package which does interactive plots. We didn't try it, but it also does 3D plots, just need to use its own syntax, which we would not have had time today.
```{r, eval=F}
plot_ly(data=gapminder %>% filter(year==2007, continent!="Asia"),  
        x=~log10(pop), y=~lifeExp, z=~gdpPercap, 
        color=~continent,
        type="scatter3d", mode="markers", 
        marker=list(opacity=0.6, size=5) 
        ) %>% 
  layout(xaxis = list(type = "log"))
```


# Making websites and slides from R

We've looked into a few ways of making plots, including interactive plots, how can we use them in presentations and publications? One way is to just click the export button on the Plots (or Viewer) tab on the right, or for ggplots, use the ggsave() command. But we can also create webpages (or html-slides) with data and plots embedded.

Try it: go to File -> New File -> RMarkdown -> leave the default, "Document" selected, and press OK. This will open a new tab in the script pane, with another R markdown document (this worksheet is also an R markdown document). It has some sample content in it - just click the blue "Knit" button up top to render it as a webpage. You could also try adding your own content - but remember to load all data and packages. Copy-paste this block there and knit again:

```{r, eval=F}
library(gapminder)
library(ggplot2)
library(plotly)

g = ggplot(gapminder, aes(x=lifeExp, y=pop, color=continent, text=country))+
  geom_point()+
  theme_minimal()+                # add before before theme()
  theme(legend.position = "top")+ # add after theme_* if one is present
  NULL
g+labs(title="A static plot")

ggplotly(g+labs(title="An interactive plot"))

```



 ---
 
 ---
 
 ---
 
 ---



